{"componentChunkName":"component---src-templates-talk-js","path":"/talks/cpp-practice-of-programming","result":{"data":{"markdownRemark":{"html":"<p>程设课的 C++ 笔记。上半学期是语法及 STL，下半学期是算法基础。</p>\n<!-- more -->\n<h2 id=\"函数及其类型\">函数及其类型</h2>\n<h3 id=\"C-11-lambda-表达式作为返回值\">C++ 11 lambda 表达式作为返回值</h3>\n<p>C++ 提供了 <code>auto</code> 关键字作自动类型推断，但在 C++ 11 中不能自动推断函数的返回值类型，必须通过 <code>decltype()</code> 指明。而 lambda 表达式没有具名类型，因此需要通过包装在<strong>函数对象</strong>（<code>function</code>）中来解决。</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;functional></span> <span class=\"token comment\">// `std::function` 在 &lt;functional> 头文件里</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\nfunction<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">></span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">=</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code>function&#x3C;></code> 类模板接收一个参数，函数的类型。仿照普通函数的类型（<code>return_type(arg_type,...)</code>）写即可。</p>\n<p>当然，在 C++ 14 及以后可以直接写成：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">auto</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">=</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"函数指针\">函数指针</h3>\n<p>一个参数表是 <code>(int, int)</code>，返回值是 <code>void</code> 的函数，它的指针类型写作 <code>void(*)(int, int)</code>。如果函数的形参是函数指针类型，需要写成：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>fun<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// &lt;- 形参名 fun 在类型的里面！</span></code></pre></div>\n<p>当然，可以使用函数模板：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">F</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>F fun<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre></div>\n<hr class=\"talk-separator\" />\n<h2 id=\"构造函数\">构造函数</h2>\n<h3 id=\"复制构造函数\">复制构造函数</h3>\n<p>形如 <code>C(const C&#x26; a)</code> 的构造函数。在没有声明的情况下，编译器会自动生成一个，执行按位拷贝（<strong>浅拷贝</strong>）。在以下三种情况会调用：</p>\n<ul>\n<li>使用另一个同类对象初始化</li>\n<li>初始化函数的形参</li>\n<li>函数以值的形式返回对象*</li>\n</ul>\n<p>C++ 17 及以上要求实现返回值优化，如果返回值是纯右值（一个直接调用构造函数生成的临时对象），不会执行复制构造函数。此外还有具名返回值优化，可以参考<a href=\"https://www.zhihu.com/question/443571654/answer/1723219351\">谷雨同学的知乎回答</a>。 </p>\n<p>以上操作的特点是，都发生了“在内存中<strong>开辟了一块新的空间</strong>，需要用一个同类对象初始化它”的事件，而在<strong>赋值</strong>操作中，赋值号左侧的左值<strong>并不是一块新的空间</strong>，因此并不调用复制构造函数。另一种理解是，<em>赋值操作过程中不涉及初始化</em> ——而构造函数本质上都是在做初始化操作。</p>\n<h3 id=\"析构函数\">析构函数</h3>\n<p>通常情况下（比如，排除 <code>new</code> 分配的空间没有用 <code>delete</code> 释放的情况），每次调用构造函数，在将来的某个时间点都会发生一次对应的析构。注意，这里的构造函数包括<strong>所有种类的构造函数</strong>：无参构造函数、类型转换构造函数、复制构造函数、移动构造函数等。</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token function\">n</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"int, \"</span><span class=\"token operator\">&lt;&lt;</span>n<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\", @\"</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token keyword\">this</span><span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> A<span class=\"token operator\">&amp;</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"&amp;,&lt;-\"</span><span class=\"token operator\">&lt;&lt;</span>a<span class=\"token punctuation\">.</span>n<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\",->@\"</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token keyword\">this</span><span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n        n<span class=\"token operator\">=</span>a<span class=\"token punctuation\">.</span>n<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">~</span><span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"~, \"</span><span class=\"token operator\">&lt;&lt;</span>n<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\", @\"</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token keyword\">this</span><span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n    A<span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> A<span class=\"token operator\">&amp;</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"=, \"</span><span class=\"token operator\">&lt;&lt;</span>n<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\" &lt;- \"</span><span class=\"token operator\">&lt;&lt;</span>a<span class=\"token punctuation\">.</span>n<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\", ->@\"</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token keyword\">this</span><span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n        n <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span>n<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    A a<span class=\"token punctuation\">{</span><span class=\"token number\">12</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"--1--\"</span><span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n    a <span class=\"token operator\">=</span> <span class=\"token number\">9</span><span class=\"token punctuation\">;</span>\n    cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"--2--\"</span><span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/*\nint, 12, @0x64fe08 // 类型转换构造函数\n--1--\nint, 9, @0x64fe0c // 隐式类型转换\n=, 12 &lt;- 9, @0x64fe08 // 赋值\n~, 9, @0x64fe0c // 临时对象析构\n--2--\n~, 9, @0x64fe08 // a 析构\n*/</span></code></pre></div>\n<hr class=\"talk-separator\" />\n<h2 id=\"移动\">移动</h2>\n<p>复制构造函数中执行开销极大的深拷贝操作，而有时我们只是想把值从变量传到另外一个变量，之后<strong>丢弃</strong>原变量，这时不必进行拷贝，可以使用<strong>移动</strong>操作。</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> a<span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> b<span class=\"token punctuation\">{</span>std<span class=\"token operator\">::</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code>std::move()</code> 标注该左值为“可移动的”，即<em>亡值</em> （可以理解为丧失其值的所有权）。亡值会优先绑定到右值引用类型上，因此会优先调用<strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>。</p>\n<p><code>std::move()</code> 本质上只是类型转换，表示可以进行移动操作，<strong>不一定实际移动了</strong>（实际移动操作在构造函数和运算符重载中进行）。之后该左值是<strong>合法</strong>但<strong>未定义</strong>的。</p>\n<p>移动构造函数和移动赋值运算符的参数是右值引用类型（<code>T&#x26;&#x26;</code>），注意没有 <code>const</code> 修饰符，因为移动操作会修改右值引用。</p>\n<p>举例来说，在类初始化列表中初始化成员对象时，使用 <code>std::move</code> 移动形参对象可以减少开销。</p>\n<hr class=\"talk-separator\" />\n<h2 id=\"内联函数\">内联函数</h2>\n<p>无论是显式声明 <code>inline</code> 还是隐式（成员函数函数体直接写在类定义内），编译器都<strong>不一定将其内联</strong>。经试验，<code>gcc</code> 在 <code>-O0</code> 下 <em>似乎</em> 不会执行内联，而在 <code>-O1</code> 下则 <em>似乎</em> 会——断点调试器中找不到显示或隐式函数了。<del>所以内联就是安慰剂</del>。</p>\n<p>成员函数即使内联，也<strong>不会计入实例化的对象的存储空间</strong>。</p>\n<hr class=\"talk-separator\" />\n<h2 id=\"输入输出流\">输入输出流</h2>\n<h3 id=\"cstdio-还是-iostream-？\"><code>&#x3C;cstdio></code> 还是 <code>&#x3C;iostream></code> ？</h3>\n<p><code>scanf</code> 和 <code>printf</code> 虽然性能好，但毕竟是 C 库函数，有几处和 C++ 习惯不符：</p>\n<ol>\n<li><code>scanf</code> 通过<strong>指针</strong>进行写入，忘记取地址符 <code>&#x26;</code> 会变得不幸😅。</li>\n<li>这两个函数并不支持 <code>string</code>（<code>string</code> 并没定义到 <code>char*</code> 的隐式类型转换），需要手动调用 <code>.c_str()</code>。</li>\n<li><code>scanf(\"%c\",...)</code> 会把<strong>空白字符</strong>读入 <code>char</code>，而 <code>cin</code> 会跳过所有空白字符。如果缓冲区里还留着上一行的换行符，它会被读入 <code>char</code>。可以使用 <code>\" %c\"</code> ，跳过缓冲区里<strong>所有空白字符</strong>。</li>\n</ol>\n<p>输入数据量特别大的情况下，可以考虑用 <code>scanf</code>。而 <code>cin</code> 慢与它和 <code>scanf</code> 同步缓冲区有关，可以使用 (<code>std::</code>)<code>ios::sync_with_stdio(false)</code> 关闭，之后性能和 <code>scanf</code> 差不多，但<strong>不再支持两个函数混用</strong>。</p>\n<p><code>cin</code> 还有一个坑，读取之后，后接的<strong>空白字符留在缓冲区</strong>里，包括<code>cin.getline()</code>。这时候再用 <code>scanf</code> 就可能出现混乱。</p>\n<p>另外，<code>&#x3C;cstdio></code> 读入一个字符的函数是 <code>getchar()</code>，而 <code>&#x3C;iostream></code> 是 <code>cin.get()</code>，丢弃字符可以直接使用 <code>cin.ignore()</code>。</p>\n<h3 id=\"格式化\">格式化</h3>\n<p><code>printf</code> 用来保留三位小数的语法是 <code>\"%.3f\"</code>，而 <code>cout</code> 需要用 <code>&#x3C;iomanip></code> 库：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">setiosflags</span><span class=\"token punctuation\">(</span>ios<span class=\"token operator\">::</span>fixed<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">setprecision</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> MY_DOUBLE <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">resetiosflags</span><span class=\"token punctuation\">(</span>ios<span class=\"token operator\">::</span>fixed<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></code></pre></div>\n<p>输出十六进制可以使用 <code>%x</code> 或者 <code>cout &#x3C;&#x3C; hex &#x3C;&#x3C; MY_INT</code>。</p>","frontmatter":{"title":"程设 C++ 笔记","date":"2021/05/07","category":"信息","tags":["编程语言","C++"],"keywords":["程序设计实习"]},"fields":{"modifiedTime":"2021/07/18"}}},"pageContext":{"slug":"talks/cpp-practice-of-programming","quarter":"talks"}},"staticQueryHashes":["2243046057","63159454"]}