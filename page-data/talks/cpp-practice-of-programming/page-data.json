{"componentChunkName":"component---src-templates-talk-js","path":"/talks/cpp-practice-of-programming","result":{"data":{"markdownRemark":{"html":"<p>程设课的 C++ 笔记。上半学期是语法及 STL，下半学期是算法基础。</p>\n<!-- more -->\n<h2 id=\"函数及其类型\">函数及其类型</h2>\n<h3 id=\"C-11-lambda-表达式作为返回值\">C++ 11 lambda 表达式作为返回值</h3>\n<p>C++ 提供了 <code>auto</code> 关键字作自动类型推断，但在 C++ 11 中不能自动推断函数的返回值类型，必须通过 <code>decltype()</code> 指明。而 lambda 表达式没有具名类型，因此需要通过包装在<strong>函数对象</strong>（<code>function</code>）中来解决。</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;functional></span> <span class=\"token comment\">// `std::function` 在 &lt;functional> 头文件里</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\nfunction<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">></span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">=</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code>function&#x3C;></code> 类模板接收一个参数，函数的类型。仿照普通函数的类型（<code>return_type(arg_type,...)</code>）写即可。</p>\n<p>当然，在 C++ 14 及以后可以直接写成：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">auto</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">=</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"函数指针\">函数指针</h3>\n<p>一个参数表是 <code>(int, int)</code>，返回值是 <code>void</code> 的函数，它的指针类型写作 <code>void(*)(int, int)</code>。如果函数的形参是函数指针类型，需要写成：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>fun<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// &lt;- 形参名 fun 在类型的里面！</span></code></pre></div>\n<p>当然，可以使用函数模板：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">F</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>F fun<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre></div>\n<hr class=\"talk-separator\" />\n<h2 id=\"构造函数\">构造函数</h2>\n<h3 id=\"复制构造函数\">复制构造函数</h3>\n<p>形如 <code>C(const C&#x26; a)</code> 的构造函数。在没有声明的情况下，编译器会自动生成一个，执行按位拷贝（<strong>浅拷贝</strong>）。在以下三种情况会调用：</p>\n<ul>\n<li>使用另一个同类对象初始化</li>\n<li>初始化函数的形参</li>\n<li>函数以值的形式返回对象*</li>\n</ul>\n<p>C++ 17 及以上要求实现返回值优化，如果返回值是纯右值（一个直接调用构造函数生成的临时对象），不会执行复制构造函数。此外还有具名返回值优化，可以参考<a href=\"https://www.zhihu.com/question/443571654/answer/1723219351\">谷雨同学的知乎回答</a>。 </p>\n<p>以上操作的特点是，都发生了“在内存中<strong>开辟了一块新的空间</strong>，需要用一个同类对象初始化它”的事件，而在<strong>赋值</strong>操作中，赋值号左侧的左值<strong>并不是一块新的空间</strong>，因此并不调用复制构造函数。另一种理解是，<em>赋值操作过程中不涉及初始化</em> ——而构造函数本质上都是在做初始化操作。</p>\n<h3 id=\"析构函数\">析构函数</h3>\n<p>通常情况下（比如，排除 <code>new</code> 分配的空间没有用 <code>delete</code> 释放的情况），每次调用构造函数，在将来的某个时间点都会发生一次对应的析构。注意，这里的构造函数包括<strong>所有种类的构造函数</strong>：无参构造函数、类型转换构造函数、复制构造函数、移动构造函数等。</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token function\">n</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"int, \"</span><span class=\"token operator\">&lt;&lt;</span>n<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\", @\"</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token keyword\">this</span><span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> A<span class=\"token operator\">&amp;</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"&amp;,&lt;-\"</span><span class=\"token operator\">&lt;&lt;</span>a<span class=\"token punctuation\">.</span>n<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\",->@\"</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token keyword\">this</span><span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n        n<span class=\"token operator\">=</span>a<span class=\"token punctuation\">.</span>n<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">~</span><span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"~, \"</span><span class=\"token operator\">&lt;&lt;</span>n<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\", @\"</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token keyword\">this</span><span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n    A<span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> A<span class=\"token operator\">&amp;</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"=, \"</span><span class=\"token operator\">&lt;&lt;</span>n<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\" &lt;- \"</span><span class=\"token operator\">&lt;&lt;</span>a<span class=\"token punctuation\">.</span>n<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\", ->@\"</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token keyword\">this</span><span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n        n <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span>n<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    A a<span class=\"token punctuation\">{</span><span class=\"token number\">12</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"--1--\"</span><span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n    a <span class=\"token operator\">=</span> <span class=\"token number\">9</span><span class=\"token punctuation\">;</span>\n    cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"--2--\"</span><span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/*\nint, 12, @0x64fe08 // 类型转换构造函数\n--1--\nint, 9, @0x64fe0c // 隐式类型转换\n=, 12 &lt;- 9, @0x64fe08 // 赋值\n~, 9, @0x64fe0c // 临时对象析构\n--2--\n~, 9, @0x64fe08 // a 析构\n*/</span></code></pre></div>\n<hr class=\"talk-separator\" />\n<h2 id=\"移动\">移动</h2>\n<p>复制构造函数中执行开销极大的深拷贝操作，而有时我们只是想把值从变量传到另外一个变量，之后<strong>丢弃</strong>原变量，这时不必进行拷贝，可以使用<strong>移动</strong>操作。</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> a<span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> b<span class=\"token punctuation\">{</span>std<span class=\"token operator\">::</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code>std::move()</code> 标注该左值为“可移动的”，即<em>亡值</em> （可以理解为丧失其值的所有权）。亡值会优先绑定到右值引用类型上，因此会优先调用<strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>。</p>\n<p><code>std::move()</code> 本质上只是类型转换，表示可以进行移动操作，<strong>不一定实际移动了</strong>（实际移动操作在构造函数和运算符重载中进行）。之后该左值是<strong>合法</strong>但<strong>未定义</strong>的。</p>\n<p>移动构造函数和移动赋值运算符的参数是右值引用类型（<code>T&#x26;&#x26;</code>），注意没有 <code>const</code> 修饰符，因为移动操作会修改右值引用。</p>\n<p>举例来说，在类初始化列表中初始化成员对象时，使用 <code>std::move</code> 移动形参对象可以减少开销。</p>","frontmatter":{"title":"程设 C++ 笔记","date":"2021/05/07","category":"信息学","tags":["编程语言","C++"],"keywords":["程序设计实习"]},"fields":{"modifiedTime":"2021/05/07"}}},"pageContext":{"slug":"talks/cpp-practice-of-programming","quarter":"talks"}},"staticQueryHashes":["2243046057","63159454"]}