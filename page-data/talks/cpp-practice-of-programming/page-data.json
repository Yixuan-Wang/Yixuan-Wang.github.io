{"componentChunkName":"component---src-templates-talk-js","path":"/talks/cpp-practice-of-programming","result":{"data":{"markdownRemark":{"html":"<p>程设课的 C++ 笔记。上半学期是语法及 STL，下半学期是算法基础。</p>\n<!-- more -->\n<h2 id=\"函数及其类型\">函数及其类型</h2>\n<h3 id=\"C-11-lambda-表达式作为返回值\">C++ 11 lambda 表达式作为返回值</h3>\n<p>C++ 提供了 <code>auto</code> 关键字作自动类型推断，但在 C++ 11 中不能自动推断函数的返回值类型，必须通过 <code>decltype()</code> 指明。而 lambda 表达式没有具名类型，因此需要通过包装在<strong>函数对象</strong>（<code>function</code>）中来解决。</p>\n<pre class=\"shiki\" style=\"background-color: #2e3440ff\"><code><span class=\"line\"><span style=\"color: #D8DEE9FF\">#include </span><span style=\"color: #81A1C1\">&lt;</span><span style=\"color: #D8DEE9FF\">functional</span><span style=\"color: #81A1C1\">&gt;</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">//</span><span style=\"color: #D8DEE9FF\"> `std::function` 在 </span><span style=\"color: #81A1C1\">&lt;</span><span style=\"color: #D8DEE9FF\">functional</span><span style=\"color: #81A1C1\">&gt;</span><span style=\"color: #D8DEE9FF\"> 头文件里</span></span>\n<span class=\"line\"><span style=\"color: #81A1C1\">using</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">namespace</span><span style=\"color: #D8DEE9FF\"> std</span><span style=\"color: #81A1C1\">;</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">function</span><span style=\"color: #ECEFF4\">&lt;</span><span style=\"color: #D8DEE9FF\">int (int)</span><span style=\"color: #ECEFF4\">&gt;</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #88C0D0\">foo</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #D8DEE9FF\">int </span><span style=\"color: #D8DEE9\">a</span><span style=\"color: #ECEFF4\">)</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #ECEFF4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">    return </span><span style=\"color: #ECEFF4\">[</span><span style=\"color: #D8DEE9FF\">=</span><span style=\"color: #ECEFF4\">](</span><span style=\"color: #D8DEE9FF\">int </span><span style=\"color: #D8DEE9\">b</span><span style=\"color: #ECEFF4\">){</span><span style=\"color: #D8DEE9FF\"> return a </span><span style=\"color: #81A1C1\">+</span><span style=\"color: #D8DEE9FF\"> b; </span><span style=\"color: #ECEFF4\">}</span><span style=\"color: #D8DEE9FF\">;</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">}</span></span></code></pre>\n<p><code>function&#x3C;></code> 类模板接收一个参数，函数的类型。仿照普通函数的类型（<code>return_type(arg_type,...)</code>）写即可。</p>\n<p>当然，在 C++ 14 及以后可以直接写成：</p>\n<pre class=\"shiki\" style=\"background-color: #2e3440ff\"><code><span class=\"line\"><span style=\"color: #D8DEE9FF\">auto </span><span style=\"color: #88C0D0\">foo</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #D8DEE9FF\">int </span><span style=\"color: #D8DEE9\">a</span><span style=\"color: #ECEFF4\">)</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #ECEFF4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">    return </span><span style=\"color: #ECEFF4\">[</span><span style=\"color: #D8DEE9FF\">=</span><span style=\"color: #ECEFF4\">](</span><span style=\"color: #D8DEE9FF\">int </span><span style=\"color: #D8DEE9\">b</span><span style=\"color: #ECEFF4\">){</span><span style=\"color: #D8DEE9FF\"> return a </span><span style=\"color: #81A1C1\">+</span><span style=\"color: #D8DEE9FF\"> b; </span><span style=\"color: #ECEFF4\">}</span><span style=\"color: #D8DEE9FF\">;</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">}</span></span></code></pre>\n<h3 id=\"函数指针\">函数指针</h3>\n<p>一个参数表是 <code>(int, int)</code>，返回值是 <code>void</code> 的函数，它的指针类型写作 <code>void(*)(int, int)</code>。如果函数的形参是函数指针类型，需要写成：</p>\n<pre class=\"shiki\" style=\"background-color: #2e3440ff\"><code><span class=\"line\"><span style=\"color: #D8DEE9FF\">void </span><span style=\"color: #88C0D0\">foo</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #D8DEE9FF\">void</span><span style=\"color: #ECEFF4\">(*</span><span style=\"color: #D8DEE9\">fun</span><span style=\"color: #ECEFF4\">)(</span><span style=\"color: #D8DEE9FF\">int</span><span style=\"color: #ECEFF4\">,</span><span style=\"color: #D8DEE9FF\"> int</span><span style=\"color: #ECEFF4\">))</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #ECEFF4\">{}</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">//</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">&lt;-</span><span style=\"color: #D8DEE9FF\"> 形参名 fun 在类型的里面！</span></span></code></pre>\n<p>当然，可以使用函数模板：</p>\n<pre class=\"shiki\" style=\"background-color: #2e3440ff\"><code><span class=\"line\"><span style=\"color: #81A1C1\">template</span><span style=\"color: #ECEFF4\">&lt;</span><span style=\"color: #D8DEE9FF\">class F</span><span style=\"color: #ECEFF4\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">void </span><span style=\"color: #88C0D0\">foo</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #D8DEE9FF\">F </span><span style=\"color: #D8DEE9\">fun</span><span style=\"color: #ECEFF4\">)</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #ECEFF4\">{}</span></span></code></pre>\n<hr class=\"talk-separator\" />\n<h2 id=\"构造函数\">构造函数</h2>\n<h3 id=\"复制构造函数\">复制构造函数</h3>\n<p>形如 <code>C(const C&#x26; a)</code> 的构造函数。在没有声明的情况下，编译器会自动生成一个，执行按位拷贝（<strong>浅拷贝</strong>）。在以下三种情况会调用：</p>\n<ul>\n<li>使用另一个同类对象初始化</li>\n<li>初始化函数的形参</li>\n<li>函数以值的形式返回对象*</li>\n</ul>\n<p>C++ 17 及以上要求实现返回值优化，如果返回值是纯右值（一个直接调用构造函数生成的临时对象），不会执行复制构造函数。此外还有具名返回值优化，可以参考<a href=\"https://www.zhihu.com/question/443571654/answer/1723219351\">谷雨同学的知乎回答</a>。</p>\n<p>以上操作的特点是，都发生了“在内存中<strong>开辟了一块新的空间</strong>，需要用一个同类对象初始化它”的事件，而在<strong>赋值</strong>操作中，赋值号左侧的左值<strong>并不是一块新的空间</strong>，因此并不调用复制构造函数。另一种理解是，<em>赋值操作过程中不涉及初始化</em> ——而构造函数本质上都是在做初始化操作。</p>\n<h3 id=\"析构函数\">析构函数</h3>\n<p>通常情况下（比如，排除 <code>new</code> 分配的空间没有用 <code>delete</code> 释放的情况），每次调用构造函数，在将来的某个时间点都会发生一次对应的析构。注意，这里的构造函数包括<strong>所有种类的构造函数</strong>：无参构造函数、类型转换构造函数、复制构造函数、移动构造函数等。</p>\n<pre class=\"shiki\" style=\"background-color: #2e3440ff\"><code><span class=\"line\"><span style=\"color: #D8DEE9FF\">#include </span><span style=\"color: #81A1C1\">&lt;</span><span style=\"color: #D8DEE9FF\">iostream</span><span style=\"color: #81A1C1\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #81A1C1\">using</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">namespace</span><span style=\"color: #D8DEE9FF\"> std</span><span style=\"color: #81A1C1\">;</span></span>\n<span class=\"line\"><span style=\"color: #81A1C1\">class</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #8FBCBB\">A</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #ECEFF4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">    int n;</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">    </span><span style=\"color: #88C0D0\">A</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #D8DEE9FF\">const int a</span><span style=\"color: #ECEFF4\">)</span><span style=\"color: #D8DEE9FF\">: </span><span style=\"color: #88C0D0\">n</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #D8DEE9FF\">a</span><span style=\"color: #ECEFF4\">)</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #ECEFF4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">        cout</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #ECEFF4\">&quot;</span><span style=\"color: #A3BE8C\">int, </span><span style=\"color: #ECEFF4\">&quot;</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #D8DEE9FF\">n</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #ECEFF4\">&quot;</span><span style=\"color: #A3BE8C\">, @</span><span style=\"color: #ECEFF4\">&quot;</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #D8DEE9FF\">this</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #D8DEE9FF\">endl;</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">    </span><span style=\"color: #88C0D0\">A</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #D8DEE9FF\">const A</span><span style=\"color: #81A1C1\">&amp;</span><span style=\"color: #D8DEE9FF\"> a</span><span style=\"color: #ECEFF4\">)</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #ECEFF4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">        cout</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #ECEFF4\">&quot;</span><span style=\"color: #A3BE8C\">&amp;,&lt;-</span><span style=\"color: #ECEFF4\">&quot;</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #D8DEE9FF\">a.n</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #ECEFF4\">&quot;</span><span style=\"color: #A3BE8C\">,-&gt;@</span><span style=\"color: #ECEFF4\">&quot;</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #D8DEE9FF\">this</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #D8DEE9FF\">endl;</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">        n=a.n;</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">    </span><span style=\"color: #81A1C1\">~</span><span style=\"color: #88C0D0\">A</span><span style=\"color: #ECEFF4\">(){</span><span style=\"color: #D8DEE9FF\"> cout</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #ECEFF4\">&quot;</span><span style=\"color: #A3BE8C\">~, </span><span style=\"color: #ECEFF4\">&quot;</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #D8DEE9FF\">n</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #ECEFF4\">&quot;</span><span style=\"color: #A3BE8C\">, @</span><span style=\"color: #ECEFF4\">&quot;</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #D8DEE9FF\">this</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #D8DEE9FF\">endl; </span><span style=\"color: #ECEFF4\">}</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">    A</span><span style=\"color: #81A1C1\">&amp;</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">operator</span><span style=\"color: #D8DEE9FF\">=</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #D8DEE9FF\">const A</span><span style=\"color: #81A1C1\">&amp;</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #D8DEE9\">a</span><span style=\"color: #ECEFF4\">)</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #ECEFF4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">        cout</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #ECEFF4\">&quot;</span><span style=\"color: #A3BE8C\">=, </span><span style=\"color: #ECEFF4\">&quot;</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #D8DEE9FF\">n</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #ECEFF4\">&quot;</span><span style=\"color: #A3BE8C\"> &lt;- </span><span style=\"color: #ECEFF4\">&quot;</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #D8DEE9FF\">a.n</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #ECEFF4\">&quot;</span><span style=\"color: #A3BE8C\">, -&gt;@</span><span style=\"color: #ECEFF4\">&quot;</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #D8DEE9FF\">this</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #D8DEE9FF\">endl;</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">        n = a.n;</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">        return </span><span style=\"color: #81A1C1\">*</span><span style=\"color: #D8DEE9FF\">this;</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">};</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">int </span><span style=\"color: #88C0D0\">main</span><span style=\"color: #ECEFF4\">(){</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">    A a</span><span style=\"color: #ECEFF4\">{</span><span style=\"color: #D8DEE9FF\">12</span><span style=\"color: #ECEFF4\">}</span><span style=\"color: #D8DEE9FF\">;</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">    cout</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #ECEFF4\">&quot;</span><span style=\"color: #A3BE8C\">--1--</span><span style=\"color: #ECEFF4\">&quot;</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #D8DEE9FF\">endl;</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">    a = 9;</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">    cout</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #ECEFF4\">&quot;</span><span style=\"color: #A3BE8C\">--2--</span><span style=\"color: #ECEFF4\">&quot;</span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #D8DEE9FF\">endl;</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">}</span></span>\n\n<span class=\"line\"><span style=\"color: #616E88\">/*</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">int, 12, @0x64fe08 </span><span style=\"color: #81A1C1\">//</span><span style=\"color: #D8DEE9FF\"> 类型转换构造函数</span></span>\n<span class=\"line\"><span style=\"color: #81A1C1\">--</span><span style=\"color: #D8DEE9FF\">1</span><span style=\"color: #81A1C1\">--</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">int, 9, @0x64fe0c </span><span style=\"color: #81A1C1\">//</span><span style=\"color: #D8DEE9FF\"> 隐式类型转换</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">=, 12 </span><span style=\"color: #81A1C1\">&lt;-</span><span style=\"color: #D8DEE9FF\"> 9, @0x64fe08 </span><span style=\"color: #81A1C1\">//</span><span style=\"color: #D8DEE9FF\"> 赋值</span></span>\n<span class=\"line\"><span style=\"color: #81A1C1\">~</span><span style=\"color: #D8DEE9FF\">, 9, @0x64fe0c </span><span style=\"color: #81A1C1\">//</span><span style=\"color: #D8DEE9FF\"> 临时对象析构</span></span>\n<span class=\"line\"><span style=\"color: #81A1C1\">--</span><span style=\"color: #D8DEE9FF\">2</span><span style=\"color: #81A1C1\">--</span></span>\n<span class=\"line\"><span style=\"color: #81A1C1\">~</span><span style=\"color: #D8DEE9FF\">, 9, @0x64fe08 </span><span style=\"color: #81A1C1\">//</span><span style=\"color: #D8DEE9FF\"> a 析构</span></span>\n<span class=\"line\"><span style=\"color: #81A1C1\">*/</span></span></code></pre>\n<hr class=\"talk-separator\" />\n<h2 id=\"移动\">移动</h2>\n<p>复制构造函数中执行开销极大的深拷贝操作，而有时我们只是想把值从变量传到另外一个变量，之后<strong>丢弃</strong>原变量，这时不必进行拷贝，可以使用<strong>移动</strong>操作。</p>\n<pre class=\"shiki\" style=\"background-color: #2e3440ff\"><code><span class=\"line\"><span style=\"color: #D8DEE9FF\">vector</span><span style=\"color: #81A1C1\">&lt;</span><span style=\"color: #D8DEE9FF\">int</span><span style=\"color: #81A1C1\">&gt;</span><span style=\"color: #D8DEE9FF\"> a</span><span style=\"color: #ECEFF4\">{</span><span style=\"color: #D8DEE9FF\">1</span><span style=\"color: #ECEFF4\">}</span><span style=\"color: #D8DEE9FF\">;</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">vector</span><span style=\"color: #81A1C1\">&lt;</span><span style=\"color: #D8DEE9FF\">int</span><span style=\"color: #81A1C1\">&gt;</span><span style=\"color: #D8DEE9FF\"> b</span><span style=\"color: #ECEFF4\">{</span><span style=\"color: #D8DEE9FF\">std::</span><span style=\"color: #88C0D0\">move</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #D8DEE9FF\">a</span><span style=\"color: #ECEFF4\">)}</span><span style=\"color: #D8DEE9FF\">;</span></span></code></pre>\n<p><code>std::move()</code> 标注该左值为“可移动的”，即<em>亡值</em> （可以理解为丧失其值的所有权）。亡值会优先绑定到右值引用类型上，因此会优先调用<strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>。</p>\n<p><code>std::move()</code> 本质上只是类型转换，表示可以进行移动操作，<strong>不一定实际移动了</strong>（实际移动操作在构造函数和运算符重载中进行）。之后该左值是<strong>合法</strong>但<strong>未定义</strong>的。</p>\n<p>移动构造函数和移动赋值运算符的参数是右值引用类型（<code>T&#x26;&#x26;</code>），注意没有 <code>const</code> 修饰符，因为移动操作会修改右值引用。</p>\n<p>举例来说，在类初始化列表中初始化成员对象时，使用 <code>std::move</code> 移动形参对象可以减少开销。</p>\n<hr class=\"talk-separator\" />\n<h2 id=\"内联函数\">内联函数</h2>\n<p>无论是显式声明 <code>inline</code> 还是隐式（成员函数函数体直接写在类定义内），编译器都<strong>不一定将其内联</strong>。经试验，<code>gcc</code> 在 <code>-O0</code> 下 <em>似乎</em> 不会执行内联，而在 <code>-O1</code> 下则 <em>似乎</em> 会——断点调试器中找不到显示或隐式函数了。<del>所以内联就是安慰剂</del>。</p>\n<p>成员函数即使内联，也<strong>不会计入实例化的对象的存储空间</strong>。</p>\n<hr class=\"talk-separator\" />\n<h2 id=\"输入输出流\">输入输出流</h2>\n<h3 id=\"cstdio-还是-iostream-？\"><code>&#x3C;cstdio></code> 还是 <code>&#x3C;iostream></code> ？</h3>\n<p><code>scanf</code> 和 <code>printf</code> 虽然性能好，但毕竟是 C 库函数，有几处和 C++ 习惯不符：</p>\n<ol>\n<li><code>scanf</code> 通过<strong>指针</strong>进行写入，忘记取地址符 <code>&#x26;</code> 会变得不幸😅。</li>\n<li>这两个函数并不支持 <code>string</code>（<code>string</code> 并没定义到 <code>char*</code> 的隐式类型转换），需要手动调用 <code>.c_str()</code>。</li>\n<li><code>scanf(\"%c\",...)</code> 会把<strong>空白字符</strong>读入 <code>char</code>，而 <code>cin</code> 会跳过所有空白字符。如果缓冲区里还留着上一行的换行符，它会被读入 <code>char</code>。可以使用 <code>\" %c\"</code> ，跳过缓冲区里<strong>所有空白字符</strong>。</li>\n</ol>\n<p>输入数据量特别大的情况下，可以考虑用 <code>scanf</code>。而 <code>cin</code> 慢与它和 <code>scanf</code> 同步缓冲区有关，可以使用 (<code>std::</code>)<code>ios::sync_with_stdio(false)</code> 关闭，之后性能和 <code>scanf</code> 差不多，但<strong>不再支持两个函数混用</strong>。</p>\n<p><code>cin</code> 还有一个坑，读取之后，后接的<strong>空白字符留在缓冲区</strong>里，包括<code>cin.getline()</code>。这时候再用 <code>scanf</code> 就可能出现混乱。</p>\n<p>另外，<code>&#x3C;cstdio></code> 读入一个字符的函数是 <code>getchar()</code>，而 <code>&#x3C;iostream></code> 是 <code>cin.get()</code>，丢弃字符可以直接使用 <code>cin.ignore()</code>。</p>\n<h3 id=\"格式化\">格式化</h3>\n<p><code>printf</code> 用来保留三位小数的语法是 <code>\"%.3f\"</code>，而 <code>cout</code> 需要用 <code>&#x3C;iomanip></code> 库：</p>\n<pre class=\"shiki\" style=\"background-color: #2e3440ff\"><code><span class=\"line\"><span style=\"color: #D8DEE9FF\">cout </span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #88C0D0\">setiosflags</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #D8DEE9FF\">ios::fixed</span><span style=\"color: #ECEFF4\">)</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #88C0D0\">setprecision</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #D8DEE9FF\">3</span><span style=\"color: #ECEFF4\">)</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #D8DEE9FF\"> MY_DOUBLE </span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #88C0D0\">resetiosflags</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #D8DEE9FF\">ios::fixed</span><span style=\"color: #ECEFF4\">)</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">&lt;&lt;</span><span style=\"color: #D8DEE9FF\"> endl;</span></span></code></pre>\n<p>输出十六进制可以使用 <code>%x</code> 或者 <code>cout &#x3C;&#x3C; hex &#x3C;&#x3C; MY_INT</code>。</p>","frontmatter":{"title":"程设 C++ 笔记","date":"2021/05/07","category":"信息","tags":["编程语言","C++"],"keywords":["程序设计实习"]},"fields":{"modifiedTime":"2021/07/18"}}},"pageContext":{"slug":"talks/cpp-practice-of-programming","quarter":"talks"}},"staticQueryHashes":["2243046057","63159454"]}