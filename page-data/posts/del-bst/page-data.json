{"componentChunkName":"component---src-templates-post-js","path":"/posts/del-bst","result":{"data":{"markdownRemark":{"html":"<p>二叉搜索树删除结点的操作实际上是一种旋转。</p>\n<!-- more -->\n  <div style=\"text-align:center;\">\n  <strong><del>生活在二叉树上</del></strong> <br/>\n  P市一辣鸡\n  </div>\n<p>用二叉树的数据结构体现存取增减最优都能达到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>的超越性，保持婞直却又不拘泥于所谓“顺序表二分查找”的单向度形象。这便是二叉搜索树为我们提供的理想期望数据结构范式。<del>生活在二叉树上——始终热爱全序——升上根结点</del>。</p>\n<h2 id=\"二叉搜索树\">二叉搜索树</h2>\n<p>回归正题。数据结构与算法 B 课程期末考试考到了二叉搜索树删除结点，自觉答得不够清晰完整，这里补充上，算是填补一下遗憾。</p>\n<p>二叉搜索树是<strong>中序遍历权值序列单调不降</strong>（或不增）的二叉树。任意一个结点，左子的权值（若存在，下同）小于等于它，右子的权值大于等于它（反过来当然也可以）。而二叉堆则是任意一个结点，左子和右子权值都大于等于它（或小于等于）。</p>\n<p>所以二叉搜索树任意一棵左右子树也都是二叉搜索树。特别无聊地，空树也是二叉搜索树。</p>\n<h2 id=\"删除结点\">删除结点</h2>\n<p>为了维护二叉搜索树的顺序关系，删除一个结点<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>o</mi></mrow><annotation encoding=\"application/x-tex\">o</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">o</span></span></span></span>以后，要用左子树<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span>最大的结点<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mi>r</mi></msub></mrow><annotation encoding=\"application/x-tex\">l_{r}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>（也就是<strong>最右下的结点</strong>）替换<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>o</mi></mrow><annotation encoding=\"application/x-tex\">o</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">o</span></span></span></span>。如果没有左子树，也就是图 b 的情况，直接把<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>变为父结点<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>的子树即可。</p>\n<div style=\"display:flex;flex-wrap:wrap;\">\n<pre style=\"flex: 1 1;\">\n[a]\n p\n  \\\n   o\n  / \\\n L   R\n</pre>\n&nbsp;\n<pre style=\"flex: 1 1;\">\n[b]\n p\n  \\\n   o\n    \\\n     R  \n</pre>\n</div>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 二叉搜索树类的 delete 方法</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">delete</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    current <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>_root <span class=\"token comment\"># current 根结点，设为当前结点</span>\n    fa <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span> <span class=\"token comment\"># fa[ther] 当前结点的父结点</span>\n\n    order <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>order <span class=\"token comment\"># 全序关系函数 order(a, b) -> Bool，二叉搜索树满足 order(左子，自己) == True</span>\n    equal <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>equal <span class=\"token comment\"># 相等关系函数 equal(a, b) -> Bool</span>\n\n    <span class=\"token keyword\">while</span> current <span class=\"token operator\">!=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> equal<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> current<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 当前结点就是目标结点</span>\n            <span class=\"token keyword\">if</span> current<span class=\"token punctuation\">.</span>lch <span class=\"token operator\">==</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># l[eft]ch[ild] 左子 左子为空</span>\n                <span class=\"token keyword\">if</span> fa <span class=\"token operator\">==</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span> self<span class=\"token punctuation\">.</span>_root <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span>rch <span class=\"token comment\"># 若要删除的是根结点，且没有左子树</span>\n                <span class=\"token keyword\">elif</span> fa<span class=\"token punctuation\">.</span>lch <span class=\"token operator\">==</span> current<span class=\"token punctuation\">:</span> fa<span class=\"token punctuation\">.</span>lch <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span>rch <span class=\"token comment\"># 当前是父结点的左子，用当前的右子替换当前结点</span>\n                <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span> fa<span class=\"token punctuation\">.</span>rch <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span>rch <span class=\"token comment\"># 当前是父结点右子，同上</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                rightmost <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span>lch <span class=\"token comment\"># rightmost 左子树最大结点，初始化为左子</span>\n                faRightmost <span class=\"token operator\">=</span> current <span class=\"token comment\"># fa[ther-of-]Rightmost 左子树最大结点的父结点，初始化为当前结点</span>\n\n                <span class=\"token keyword\">while</span> rightmost<span class=\"token punctuation\">.</span>rch <span class=\"token operator\">!=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span> faRightmost<span class=\"token punctuation\">,</span> rightmost <span class=\"token operator\">=</span> rightmost<span class=\"token punctuation\">,</span> rightmost<span class=\"token punctuation\">.</span>rch\n                <span class=\"token comment\"># 循环找最右下结点</span>\n\n                <span class=\"token keyword\">if</span> faRightmost <span class=\"token operator\">==</span> current<span class=\"token punctuation\">:</span> faRightmost<span class=\"token punctuation\">.</span>lch <span class=\"token operator\">=</span> rightmost<span class=\"token punctuation\">.</span>lch <span class=\"token comment\"># 当前结点左子的右子树为空，用左子的左子替代左子</span>\n                <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span> faRightmost<span class=\"token punctuation\">.</span>rch <span class=\"token operator\">=</span> rightmost<span class=\"token punctuation\">.</span>lch <span class=\"token comment\"># 最大结点用左子替代</span>\n\n                rightmost<span class=\"token punctuation\">.</span>lch <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span>lch <span class=\"token comment\"># 替换最右下结点的子结点引用</span>\n                rightmost<span class=\"token punctuation\">.</span>rch <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span>rch\n                <span class=\"token keyword\">if</span> fa <span class=\"token operator\">==</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span> self<span class=\"token punctuation\">.</span>_root <span class=\"token operator\">=</span> rightmost <span class=\"token comment\"># 若当前结点是根节点，不用改变父的子结点引用</span>\n                <span class=\"token keyword\">elif</span> fa<span class=\"token punctuation\">.</span>lch <span class=\"token operator\">==</span> current<span class=\"token punctuation\">:</span> fa<span class=\"token punctuation\">.</span>lch <span class=\"token operator\">=</span> rightmost <span class=\"token comment\"># 替换当前结点父结点的子结点引用</span>\n                <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span> fa<span class=\"token punctuation\">.</span>rch <span class=\"token operator\">=</span> rightmost\n                <span class=\"token comment\"># 左子树上最大结点替代当前结点</span>\n\n            <span class=\"token keyword\">del</span> current <span class=\"token comment\"># 删除当前结点</span>\n            <span class=\"token keyword\">return</span>\n        <span class=\"token keyword\">elif</span> order<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> current<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> fa<span class=\"token punctuation\">,</span> current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">,</span> current<span class=\"token punctuation\">.</span>lch <span class=\"token comment\"># 找目标结点</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span> fa<span class=\"token punctuation\">,</span> current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">,</span> current<span class=\"token punctuation\">.</span>rch</code></pre></div>\n<h2 id=\"旋转\">旋转</h2>\n<p>课程里没有提及旋转的概念。后来一位前 OIer 朋友（<a href=\"https://www.cnblogs.com/FYH-SSGSS/\">@FYH</a>）给我科普，以上删除结点的操作其实涉及到了旋转。</p>\n<p>对于以下两棵二叉搜索树：</p>\n<div style=\"display:flex;flex-wrap:wrap;\">\n<pre style=\"flex: 1 1;\">\n[a]\n    3*\n   / \\\n  2   4\n /     \\\n1       5\n</pre>\n&nbsp;\n<pre style=\"flex: 1 1;\">\n[b]\n 1\n  \\   \n   2\n    \\\n     3*\n      \\\n       4\n        \\\n         5\n</pre>\n</div>\n<p>存储的数据是完全相同的，但是树 a 中搜索的最坏时间复杂度达到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，树 b 中搜索则达到了<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。二叉树构造得越“平衡”，在其上进行操作的性能就越好。为了使 b 变得更平衡，可以以标 <code>*</code> 的 3 号结点为新的根结点，将它的祖先结点<strong>旋转</strong>为它的左子树，变成树 a。</p>\n<p>同样地，二叉搜索树删除结点操作也可以视为以待删除结点左子树的最大结点为中心，将待删除结点的左子树旋转为它的左子树，再将待删除结点的右子树接在旋转的中心上。</p>\n<h2 id=\"参考资料\">参考资料</h2>\n<ul>\n<li>OI Wiki，<a href=\"https://oi-wiki.org/ds/bst/\">二叉搜索树</a></li>\n<li>裘宗燕，数据结构与算法：Python 语言描述，2018</li>\n</ul>","frontmatter":{"title":"二叉搜索树的删除结点操作","date":"2020/09/18","category":"信息学","tags":["数据结构"],"keywords":["树"]},"fields":{"modifiedTime":"2021/06/05"}}},"pageContext":{"slug":"posts/del-bst","quarter":"posts"}},"staticQueryHashes":["2243046057","63159454"]}